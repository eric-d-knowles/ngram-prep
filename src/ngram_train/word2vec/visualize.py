"""
Visualization utilities for Word2Vec evaluation results.

Provides functions to plot evaluation metrics from CSV files generated by evaluate_models().
"""

import logging

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

__all__ = ["plot_evaluation_results"]


def plot_evaluation_results(
    csv_file,
    metric,
    x_vars,
    plot_type="line",
    output_file=None,
    plot_title=None,
    label_map=None,
    panel_by=None
):
    """
    Plot evaluation results from CSV file generated by evaluate_models().

    Creates visualizations of model performance across hyperparameter configurations.
    Supports line plots, contour plots, and 3D surface plots.

    Args:
        csv_file (str): Path to the evaluation results CSV file.
        metric (str): Metric to plot ('similarity_score' or 'analogy_score').
        x_vars (str or list): Variable(s) for plotting. Can be:
            - Single string: Simple line plot with one x-axis variable
            - List of 2 strings: Line plot with hue, or 2D contour/surface plot
            - List of 3 strings: 3D scatter plot (contour type only)
        plot_type (str): Type of plot ('line', 'contour', or 'surface'). Defaults to 'line'.
        output_file (str, optional): Path to save the plot. If None, displays interactively.
        plot_title (str, optional): Custom title for the plot. If None, generates default title.
        label_map (dict, optional): Mapping of column names to display labels. If None, uses defaults.
        panel_by (str, optional): Variable to create subplots for. Each unique value gets its own panel.

    Returns:
        pd.DataFrame: The loaded evaluation results dataframe, or None if loading failed.

    Raises:
        FileNotFoundError: If csv_file doesn't exist.
        ValueError: If required columns are missing or plot configuration is invalid.

    Example:
        >>> # Simple line plot
        >>> plot_evaluation_results(
        ...     csv_file="results.csv",
        ...     metric="similarity_score",
        ...     x_vars="vector_size",
        ...     output_file="similarity_by_dim.png"
        ... )

        >>> # Grouped line plot
        >>> plot_evaluation_results(
        ...     csv_file="results.csv",
        ...     metric="analogy_score",
        ...     x_vars=["epochs", "weight_by"],
        ...     plot_type="line"
        ... )

        >>> # Contour plot
        >>> plot_evaluation_results(
        ...     csv_file="results.csv",
        ...     metric="similarity_score",
        ...     x_vars=["vector_size", "window"],
        ...     plot_type="contour"
        ... )
    """
    # Default label map
    default_label_map = {
        'vector_size': 'Vector Dimensions',
        'epochs': 'Training Epochs',
        'weight_by': 'Weighting Method',
        'min_count': 'Minimum Token Count',
        'window': 'Context Window',
        'similarity_score': 'Similarity Score',
        'analogy_score': 'Analogy Score'
    }

    if label_map is None:
        label_map = default_label_map
    else:
        # Merge with defaults
        label_map = {**default_label_map, **label_map}

    # Load CSV
    try:
        df = pd.read_csv(csv_file)
    except Exception as e:
        logging.error(f"Failed to load CSV file {csv_file}: {e}")
        return None

    # Modern colorblind-friendly palette (IBM Design Color Palette)
    colorblind_palette = [
        '#648FFF',  # Blue
        '#785EF0',  # Purple
        '#DC267F',  # Magenta
        '#FE6100',  # Orange
        '#FFB000',  # Yellow
        '#000000',  # Black
        '#00B4D8',  # Cyan
        '#90E0EF',  # Light cyan
    ]

    # Set modern seaborn theme
    sns.set_theme(
        style="ticks",
        context="notebook",
        rc={
            "font.family": "sans-serif",
            "font.sans-serif": ["Arial", "DejaVu Sans", "Liberation Sans", "sans-serif"],
            "font.size": 11,
            "axes.labelsize": 13,
            "axes.titlesize": 14,
            "axes.titleweight": "bold",
            "axes.labelweight": "normal",
            "xtick.labelsize": 10,
            "ytick.labelsize": 10,
            "legend.fontsize": 10,
            "legend.title_fontsize": 11,
            "axes.spines.top": False,
            "axes.spines.right": False,
            "axes.linewidth": 1.2,
            "grid.alpha": 0.3,
            "grid.linewidth": 0.8,
            "lines.linewidth": 2.5,
            "lines.markersize": 8,
        }
    )

    # Ensure x_vars is a list
    if isinstance(x_vars, str):
        x_vars = [x_vars]

    # Validate columns
    cols_to_check = x_vars + [metric]
    if panel_by:
        cols_to_check.append(panel_by)
    for col in cols_to_check:
        if col not in df.columns:
            raise ValueError(f"Column '{col}' not found in the DataFrame.")

    # Close any existing figures to avoid duplicates
    plt.close('all')

    # Handle paneling
    if panel_by:
        panel_values = sorted(df[panel_by].unique())
        n_panels = len(panel_values)

        # Calculate grid dimensions
        n_cols = min(3, n_panels)  # Max 3 columns
        n_rows = int(np.ceil(n_panels / n_cols))

        # Create subplot grid (not for 3D plots initially)
        is_3d_plot = plot_type == "surface" or (plot_type == "contour" and len(x_vars) == 3)

        if is_3d_plot:
            fig = plt.figure(figsize=(6 * n_cols, 5 * n_rows), dpi=100)
        else:
            fig, axes = plt.subplots(n_rows, n_cols, figsize=(6 * n_cols, 5 * n_rows), dpi=100,
                                    squeeze=False, sharey=True)
            axes = axes.flatten()

        # Calculate global y-axis limits for consistent scaling
        if not is_3d_plot and plot_type == "line":
            group_vars = x_vars if isinstance(x_vars, list) else [x_vars]
            # Include panel_by in grouping to ensure we get all unique combinations
            all_group_vars = group_vars + [panel_by]
            all_grouped = df.groupby(all_group_vars)[metric].mean().reset_index()
            y_min, y_max = all_grouped[metric].min(), all_grouped[metric].max()
            y_range = y_max - y_min
            # Add 10% padding to ensure values aren't cut off
            global_ylim = (y_min - 0.1 * y_range, y_max + 0.1 * y_range)
        else:
            global_ylim = None

        # Plot each panel
        for idx, panel_val in enumerate(panel_values):
            # Filter data for this panel
            panel_df = df[df[panel_by] == panel_val]

            # Group by x_vars and calculate mean
            group_vars = x_vars if isinstance(x_vars, list) else [x_vars]
            grouped = panel_df.groupby(group_vars)[metric].mean().reset_index()
            grouped = grouped.sort_values(by=group_vars)

            # Get appropriate axis
            if is_3d_plot:
                ax = fig.add_subplot(n_rows, n_cols, idx + 1, projection='3d')
            else:
                ax = axes[idx]

            # Determine if this is a leftmost panel (should show y-axis)
            is_leftmost = (idx % n_cols) == 0

            # Create panel subtitle (just the value, not the variable name)
            panel_subtitle = str(panel_val)
            # Capitalize common abbreviations
            if panel_subtitle.lower() == 'cbow':
                panel_subtitle = 'CBOW'
            elif panel_subtitle.lower() == 'skipgram':
                panel_subtitle = 'Skip-gram'

            # Call plotting function for this panel
            _plot_single(ax, grouped, x_vars, metric, plot_type, colorblind_palette,
                        label_map, panel_subtitle, is_panel=True,
                        is_leftmost=is_leftmost, global_ylim=global_ylim)

        # Hide extra subplots if any
        if not is_3d_plot:
            for idx in range(n_panels, len(axes)):
                axes[idx].axis('off')

        # Add overall figure title if provided
        if plot_title:
            fig.suptitle(plot_title, fontsize=16, fontweight='bold', y=0.98)

        # Create single legend for multi-variable line plots
        if not is_3d_plot and plot_type == "line" and len(x_vars) == 2:
            # Get handles and labels from the first axis that has a legend
            handles, labels = None, None
            for ax in axes[:n_panels]:
                h, l = ax.get_legend_handles_labels()
                if h:
                    handles, labels = h, l
                    break

            # Remove individual legends from all axes
            for ax in axes[:n_panels]:
                legend = ax.get_legend()
                if legend:
                    legend.remove()

            # Add a single legend for the entire figure, outside plot area
            if handles:
                fig.legend(handles, labels,
                          title=label_map.get(x_vars[1], x_vars[1]),
                          loc='center left',
                          bbox_to_anchor=(1.02, 0.5),
                          frameon=False)
    else:
        # Single plot (original behavior)
        # Group by x_vars and calculate mean
        group_vars = x_vars if isinstance(x_vars, list) else [x_vars]
        grouped = df.groupby(group_vars)[metric].mean().reset_index()
        grouped = grouped.sort_values(by=group_vars)

        # Create figure with modern styling (skip for 3D plots that create their own)
        # 3D plots: surface, and contour with 3 vars
        is_3d_plot = plot_type == "surface" or (plot_type == "contour" and len(x_vars) == 3)

        if not is_3d_plot:
            fig, ax = plt.subplots(figsize=(10, 6), dpi=100)
        else:
            fig, ax = None, None

        _plot_single(ax, grouped, x_vars, metric, plot_type, colorblind_palette,
                    label_map, plot_title, is_panel=False)

    # Apply tight layout with error handling
    try:
        plt.tight_layout()
    except Exception:
        pass  # Skip tight_layout if it fails, bbox_inches='tight' will handle it

    # Save or show with high quality
    if output_file:
        plt.savefig(output_file, bbox_inches="tight", dpi=300, facecolor='white')
        logging.info(f"Plot saved to {output_file}")
    else:
        plt.show()

    return df


def _plot_single(ax, grouped, x_vars, metric, plot_type, colorblind_palette,
                label_map, plot_title, is_panel=False, is_leftmost=True, global_ylim=None):
    """Helper function to plot a single panel."""
    # Ensure x_vars is a list
    if isinstance(x_vars, str):
        x_vars = [x_vars]

    if plot_type == "line":
        if len(x_vars) == 1:
            # Simple line plot
            sns.lineplot(
                data=grouped,
                x=x_vars[0],
                y=metric,
                marker="o",
                color=colorblind_palette[0],
                linewidth=2.5,
                markersize=8,
                ax=ax
            )
            ax.set_title(
                plot_title if plot_title
                else f"{label_map.get(metric, metric)} by {label_map.get(x_vars[0], x_vars[0])}",
                pad=15 if is_panel else 20
            )
            ax.set_xlabel(label_map.get(x_vars[0], x_vars[0]), labelpad=10)
            ax.grid(True, alpha=0.3, linestyle='-', linewidth=0.8)

            # Format x-axis to show integers only, using actual data points
            from matplotlib.ticker import FixedLocator
            x_values = sorted(grouped[x_vars[0]].unique())
            ax.xaxis.set_major_locator(FixedLocator(x_values))
            ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'{int(x)}'))

            # Adjust y-axis to reduce empty space
            if global_ylim:
                ax.set_ylim(global_ylim)
            else:
                y_min, y_max = grouped[metric].min(), grouped[metric].max()
                y_range = y_max - y_min
                ax.set_ylim(y_min - 0.05 * y_range, y_max + 0.05 * y_range)

            # Only show y-axis label on leftmost panels
            if is_leftmost or not is_panel:
                ax.set_ylabel(label_map.get(metric, metric), labelpad=10)

            sns.despine()

        elif len(x_vars) == 2:
            # Grouped line plot with hue
            n_colors = grouped[x_vars[1]].nunique()
            sns.lineplot(
                data=grouped,
                x=x_vars[0],
                y=metric,
                hue=x_vars[1],
                marker="o",
                palette=colorblind_palette[:n_colors],
                linewidth=2.5,
                markersize=8,
                ax=ax
            )
            ax.set_title(
                plot_title if plot_title
                else f"{label_map.get(metric, metric)} vs {label_map.get(x_vars[0], x_vars[0])} "
                     f"by {label_map.get(x_vars[1], x_vars[1])}",
                pad=15 if is_panel else 20
            )
            ax.set_xlabel(label_map.get(x_vars[0], x_vars[0]), labelpad=10)
            ax.legend(title=label_map.get(x_vars[1], x_vars[1]), frameon=False)
            ax.grid(True, alpha=0.3, linestyle='-', linewidth=0.8)

            # Format x-axis to show integers only, using actual data points
            from matplotlib.ticker import FixedLocator
            x_values = sorted(grouped[x_vars[0]].unique())
            ax.xaxis.set_major_locator(FixedLocator(x_values))
            ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'{int(x)}'))

            # Adjust y-axis to reduce empty space
            if global_ylim:
                ax.set_ylim(global_ylim)
            else:
                y_min, y_max = grouped[metric].min(), grouped[metric].max()
                y_range = y_max - y_min
                ax.set_ylim(y_min - 0.05 * y_range, y_max + 0.05 * y_range)

            # Only show y-axis label on leftmost panels
            if is_leftmost or not is_panel:
                ax.set_ylabel(label_map.get(metric, metric), labelpad=10)

            sns.despine()

        else:
            raise ValueError("Line plots support at most two x_vars.")

    elif plot_type == "contour":
        if len(x_vars) == 2:
            # 2D contour plot with modern colorblind-friendly colormap
            # Handle categorical variables by converting to numeric indices
            x_col = grouped[x_vars[0]]
            y_col = grouped[x_vars[1]]
            z = grouped[metric].values

            # Check if variables are numeric or categorical
            x_is_numeric = np.issubdtype(x_col.dtype, np.number)
            y_is_numeric = np.issubdtype(y_col.dtype, np.number)

            if x_is_numeric:
                x_unique = np.unique(x_col)
                x_values = x_col.values
                x_labels = None
            else:
                x_unique = x_col.unique()
                x_values = np.arange(len(x_col))
                x_labels = x_unique

            if y_is_numeric:
                y_unique = np.unique(y_col)
                y_values = y_col.values
                y_labels = None
            else:
                y_unique = y_col.unique()
                y_values = np.arange(len(y_col))
                y_labels = y_unique

            # Create meshgrid
            if x_is_numeric and y_is_numeric:
                X, Y = np.meshgrid(x_unique, y_unique)
            elif x_is_numeric and not y_is_numeric:
                X, Y = np.meshgrid(x_unique, np.arange(len(y_unique)))
            elif not x_is_numeric and y_is_numeric:
                X, Y = np.meshgrid(np.arange(len(x_unique)), y_unique)
            else:
                X, Y = np.meshgrid(np.arange(len(x_unique)), np.arange(len(y_unique)))

            Z = np.zeros_like(X, dtype=float)

            # Fill Z values
            for i in range(len(grouped)):
                if x_is_numeric:
                    xi = np.where(x_unique == x_col.iloc[i])[0][0]
                else:
                    xi = np.where(x_unique == x_col.iloc[i])[0][0]

                if y_is_numeric:
                    yi = np.where(y_unique == y_col.iloc[i])[0][0]
                else:
                    yi = np.where(y_unique == y_col.iloc[i])[0][0]

                Z[yi, xi] = z[i]

            # Use colorblind-friendly cividis colormap
            cmap = plt.cm.cividis
            levels = 15
            cont = ax.contourf(X, Y, Z, levels=levels, cmap=cmap, alpha=0.9)
            cbar = plt.colorbar(cont, ax=ax, label=label_map.get(metric, metric), pad=0.02)
            cbar.ax.tick_params(labelsize=9)

            # Set axis labels for categorical variables
            if x_labels is not None:
                ax.set_xticks(np.arange(len(x_labels)))
                ax.set_xticklabels(x_labels)
            if y_labels is not None:
                ax.set_yticks(np.arange(len(y_labels)))
                ax.set_yticklabels(y_labels)

            ax.set_title(
                plot_title if plot_title
                else f"{label_map.get(metric, metric)}: {label_map.get(x_vars[0], x_vars[0])} vs {label_map.get(x_vars[1], x_vars[1])}",
                pad=20
            )
            ax.set_xlabel(label_map.get(x_vars[0], x_vars[0]))
            ax.set_ylabel(label_map.get(x_vars[1], x_vars[1]))
            sns.despine()

        elif len(x_vars) == 3:
            # 3D scatter with color representing the metric
            # Handle categorical variables by converting to numeric indices
            x_col = grouped[x_vars[0]]
            y_col = grouped[x_vars[1]]
            z_col = grouped[x_vars[2]]
            metric_values = grouped[metric].values

            # Check if variables are numeric or categorical
            x_is_numeric = np.issubdtype(x_col.dtype, np.number)
            y_is_numeric = np.issubdtype(y_col.dtype, np.number)
            z_is_numeric = np.issubdtype(z_col.dtype, np.number)

            # Convert to numeric values
            if x_is_numeric:
                x = x_col.values
                x_labels = None
            else:
                x_unique = x_col.unique()
                x = np.array([np.where(x_unique == val)[0][0] for val in x_col])
                x_labels = x_unique

            if y_is_numeric:
                y = y_col.values
                y_labels = None
            else:
                y_unique = y_col.unique()
                y = np.array([np.where(y_unique == val)[0][0] for val in y_col])
                y_labels = y_unique

            if z_is_numeric:
                z = z_col.values
                z_labels = None
            else:
                z_unique = z_col.unique()
                z = np.array([np.where(z_unique == val)[0][0] for val in z_col])
                z_labels = z_unique

            # Create figure if not provided (single plot case)
            if ax is None:
                fig = plt.figure(figsize=(11, 7), dpi=100)
                ax = fig.add_subplot(111, projection='3d')
            else:
                fig = ax.figure

            # Use colorblind-friendly cividis colormap
            sc = ax.scatter(x, y, z, c=metric_values, cmap=plt.cm.cividis,
                          s=80, alpha=0.8, edgecolors='white', linewidth=0.5)
            cbar = fig.colorbar(sc, ax=ax, label=label_map.get(metric, metric),
                               shrink=0.7, pad=0.1)
            cbar.ax.tick_params(labelsize=9)

            # Set axis labels for categorical variables
            if x_labels is not None:
                ax.set_xticks(np.arange(len(x_labels)))
                ax.set_xticklabels(x_labels)
            if y_labels is not None:
                ax.set_yticks(np.arange(len(y_labels)))
                ax.set_yticklabels(y_labels)
            if z_labels is not None:
                ax.set_zticks(np.arange(len(z_labels)))
                ax.set_zticklabels(z_labels)

            ax.set_xlabel(label_map.get(x_vars[0], x_vars[0]), labelpad=10)
            ax.set_ylabel(label_map.get(x_vars[1], x_vars[1]), labelpad=10)
            ax.set_zlabel(label_map.get(x_vars[2], x_vars[2]), labelpad=10)
            ax.set_title(
                plot_title if plot_title
                else f"{label_map.get(metric, metric)}: {label_map.get(x_vars[0], x_vars[0])}, {label_map.get(x_vars[1], x_vars[1])}, {label_map.get(x_vars[2], x_vars[2])}",
                pad=20
            )
            ax.xaxis.pane.fill = False
            ax.yaxis.pane.fill = False
            ax.zaxis.pane.fill = False
            ax.grid(True, alpha=0.3)
        else:
            raise ValueError("Contour plots require two or three x_vars.")

    elif plot_type == "surface":
        if len(x_vars) != 2:
            raise ValueError("Surface plots require exactly two x_vars.")

        # 3D surface plot with modern colorblind-friendly styling
        # Handle categorical variables by converting to numeric indices
        x_col = grouped[x_vars[0]]
        y_col = grouped[x_vars[1]]
        z = grouped[metric].values

        # Check if variables are numeric or categorical
        x_is_numeric = np.issubdtype(x_col.dtype, np.number)
        y_is_numeric = np.issubdtype(y_col.dtype, np.number)

        if x_is_numeric:
            x_unique = np.unique(x_col)
            x_labels = None
        else:
            x_unique = x_col.unique()
            x_labels = x_unique

        if y_is_numeric:
            y_unique = np.unique(y_col)
            y_labels = None
        else:
            y_unique = y_col.unique()
            y_labels = y_unique

        # Create meshgrid with numeric values
        if x_is_numeric and y_is_numeric:
            X, Y = np.meshgrid(x_unique, y_unique)
        elif x_is_numeric and not y_is_numeric:
            X, Y = np.meshgrid(x_unique, np.arange(len(y_unique)))
        elif not x_is_numeric and y_is_numeric:
            X, Y = np.meshgrid(np.arange(len(x_unique)), y_unique)
        else:
            X, Y = np.meshgrid(np.arange(len(x_unique)), np.arange(len(y_unique)))

        Z = np.zeros_like(X, dtype=float)

        # Fill Z values
        for i in range(len(grouped)):
            if x_is_numeric:
                xi = np.where(x_unique == x_col.iloc[i])[0][0]
            else:
                xi = np.where(x_unique == x_col.iloc[i])[0][0]

            if y_is_numeric:
                yi = np.where(y_unique == y_col.iloc[i])[0][0]
            else:
                yi = np.where(y_unique == y_col.iloc[i])[0][0]

            Z[yi, xi] = z[i]

        # Create figure if not provided (single plot case)
        if ax is None:
            fig = plt.figure(figsize=(11, 7), dpi=100)
            ax = fig.add_subplot(111, projection='3d')
        else:
            fig = ax.figure

        # Use colorblind-friendly cividis colormap with modern styling
        surf = ax.plot_surface(X, Y, Z, cmap=plt.cm.cividis,
                              edgecolor='none', alpha=0.9,
                              antialiased=True, linewidth=0)
        cbar = fig.colorbar(surf, ax=ax, label=label_map.get(metric, metric),
                           shrink=0.7, pad=0.1)
        cbar.ax.tick_params(labelsize=9)

        # Set axis labels for categorical variables
        if x_labels is not None:
            ax.set_xticks(np.arange(len(x_labels)))
            ax.set_xticklabels(x_labels)
        if y_labels is not None:
            ax.set_yticks(np.arange(len(y_labels)))
            ax.set_yticklabels(y_labels)

        ax.set_xlabel(label_map.get(x_vars[0], x_vars[0]), labelpad=10)
        ax.set_ylabel(label_map.get(x_vars[1], x_vars[1]), labelpad=10)
        ax.set_zlabel(label_map.get(metric, metric), labelpad=10)

        ax.set_title(
            plot_title if plot_title
            else f"{label_map.get(metric, metric)}: {label_map.get(x_vars[0], x_vars[0])} vs {label_map.get(x_vars[1], x_vars[1])}",
            pad=20
        )

        # Modern 3D styling
        ax.xaxis.pane.fill = False
        ax.yaxis.pane.fill = False
        ax.zaxis.pane.fill = False
        ax.grid(True, alpha=0.3)
        ax.view_init(elev=25, azim=45)

    else:
        raise ValueError(f"Unsupported plot type: '{plot_type}'. Choose 'line', 'contour', or 'surface'.")
