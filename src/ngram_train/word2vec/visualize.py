"""
Visualization utilities for Word2Vec evaluation results.

Provides functions to plot evaluation metrics from CSV files generated by evaluate_models().
"""

import logging

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

__all__ = ["plot_evaluation_results"]


def plot_evaluation_results(
    csv_file,
    metric,
    x_vars,
    plot_type="line",
    output_file=None,
    plot_title=None,
    label_map=None
):
    """
    Plot evaluation results from CSV file generated by evaluate_models().

    Creates visualizations of model performance across hyperparameter configurations.
    Supports line plots, contour plots, and 3D surface plots.

    Args:
        csv_file (str): Path to the evaluation results CSV file.
        metric (str): Metric to plot ('similarity_score' or 'analogy_score').
        x_vars (str or list): Variable(s) for plotting. Can be:
            - Single string: Simple line plot with one x-axis variable
            - List of 2 strings: Line plot with hue, or 2D contour/surface plot
            - List of 3 strings: 3D scatter plot (contour type only)
        plot_type (str): Type of plot ('line', 'contour', or 'surface'). Defaults to 'line'.
        output_file (str, optional): Path to save the plot. If None, displays interactively.
        plot_title (str, optional): Custom title for the plot. If None, generates default title.
        label_map (dict, optional): Mapping of column names to display labels. If None, uses defaults.

    Returns:
        pd.DataFrame: The loaded evaluation results dataframe, or None if loading failed.

    Raises:
        FileNotFoundError: If csv_file doesn't exist.
        ValueError: If required columns are missing or plot configuration is invalid.

    Example:
        >>> # Simple line plot
        >>> plot_evaluation_results(
        ...     csv_file="results.csv",
        ...     metric="similarity_score",
        ...     x_vars="vector_size",
        ...     output_file="similarity_by_dim.png"
        ... )

        >>> # Grouped line plot
        >>> plot_evaluation_results(
        ...     csv_file="results.csv",
        ...     metric="analogy_score",
        ...     x_vars=["epochs", "weight_by"],
        ...     plot_type="line"
        ... )

        >>> # Contour plot
        >>> plot_evaluation_results(
        ...     csv_file="results.csv",
        ...     metric="similarity_score",
        ...     x_vars=["vector_size", "window"],
        ...     plot_type="contour"
        ... )
    """
    # Default label map
    default_label_map = {
        'vector_size': 'Vector Dimensions',
        'epochs': 'Training Epochs',
        'weight_by': 'Weighting Method',
        'min_count': 'Minimum Token Count',
        'window': 'Context Window',
        'similarity_score': 'Similarity Score',
        'analogy_score': 'Analogy Score'
    }

    if label_map is None:
        label_map = default_label_map
    else:
        # Merge with defaults
        label_map = {**default_label_map, **label_map}

    # Load CSV
    try:
        df = pd.read_csv(csv_file)
    except Exception as e:
        logging.error(f"Failed to load CSV file {csv_file}: {e}")
        return None

    # Set seaborn theme
    sns.set_theme(
        style="whitegrid",
        context="talk",
        rc={
            "font.size": 12,
            "axes.labelsize": 12,
            "xtick.labelsize": 10,
            "ytick.labelsize": 10
        }
    )

    # Ensure x_vars is a list
    if isinstance(x_vars, str):
        x_vars = [x_vars]

    # Validate columns
    for col in x_vars + [metric]:
        if col not in df.columns:
            raise ValueError(f"Column '{col}' not found in the DataFrame.")

    # Group by x_vars and calculate mean
    grouped = df.groupby(x_vars)[metric].mean().reset_index()
    grouped = grouped.sort_values(by=x_vars)

    # Create figure
    plt.figure(figsize=(8, 5))

    if plot_type == "line":
        if len(x_vars) == 1:
            # Simple line plot
            sns.lineplot(
                data=grouped,
                x=x_vars[0],
                y=metric,
                marker="o",
                color="blue"
            )
            plt.title(
                plot_title if plot_title
                else f"{label_map.get(metric, metric)} vs {label_map.get(x_vars[0], x_vars[0])}"
            )
            plt.xlabel(label_map.get(x_vars[0], x_vars[0]))
            plt.ylabel(label_map.get(metric, metric))
            plt.grid(True)

        elif len(x_vars) == 2:
            # Grouped line plot with hue
            sns.lineplot(
                data=grouped,
                x=x_vars[0],
                y=metric,
                hue=x_vars[1],
                marker="o",
                palette="tab10"
            )
            plt.title(
                plot_title if plot_title
                else f"{label_map.get(metric, metric)} vs {label_map.get(x_vars[0], x_vars[0])} "
                     f"grouped by {label_map.get(x_vars[1], x_vars[1])}"
            )
            plt.xlabel(label_map.get(x_vars[0], x_vars[0]))
            plt.ylabel(label_map.get(metric, metric))
            plt.legend(title=label_map.get(x_vars[1], x_vars[1]))
            plt.grid(True)

        else:
            raise ValueError("Line plots support at most two x_vars.")

    elif plot_type == "contour":
        if len(x_vars) == 2:
            # 2D contour plot
            x = grouped[x_vars[0]].values
            y = grouped[x_vars[1]].values
            z = grouped[metric].values
            x_unique, y_unique = np.unique(x), np.unique(y)
            X, Y = np.meshgrid(x_unique, y_unique)
            Z = np.zeros_like(X, dtype=float)

            for i in range(len(x)):
                xi = np.where(x_unique == x[i])[0][0]
                yi = np.where(y_unique == y[i])[0][0]
                Z[yi, xi] = z[i]

            cmap = sns.color_palette("viridis", as_cmap=True)
            cont = plt.contourf(X, Y, Z, cmap=cmap)
            plt.colorbar(cont, label=label_map.get(metric, metric))

            plt.title(
                plot_title if plot_title
                else f"{label_map.get(metric, metric)} Contour Plot"
            )
            plt.xlabel(label_map.get(x_vars[0], x_vars[0]))
            plt.ylabel(label_map.get(x_vars[1], x_vars[1]))

        elif len(x_vars) == 3:
            # 3D scatter with color representing the metric
            x = grouped[x_vars[0]].values
            y = grouped[x_vars[1]].values
            z = grouped[x_vars[2]].values
            metric_values = grouped[metric].values

            fig = plt.figure(figsize=(9, 6))
            ax = fig.add_subplot(111, projection='3d')

            sc = ax.scatter(x, y, z, c=metric_values, cmap="viridis")
            fig.colorbar(sc, ax=ax, label=label_map.get(metric, metric))

            ax.set_xlabel(label_map.get(x_vars[0], x_vars[0]))
            ax.set_ylabel(label_map.get(x_vars[1], x_vars[1]))
            ax.set_zlabel(label_map.get(x_vars[2], x_vars[2]))
            plt.title(
                plot_title if plot_title
                else f"{label_map.get(metric, metric)} 3D Scatter Plot"
            )
        else:
            raise ValueError("Contour plots require two or three x_vars.")

    elif plot_type == "surface":
        if len(x_vars) == 2:
            # 3D surface plot
            x = grouped[x_vars[0]].values
            y = grouped[x_vars[1]].values
            z = grouped[metric].values

            x_unique, y_unique = np.unique(x), np.unique(y)
            X, Y = np.meshgrid(x_unique, y_unique)
            Z = np.zeros_like(X, dtype=float)

            for i in range(len(x)):
                xi = np.where(x_unique == x[i])[0][0]
                yi = np.where(y_unique == y[i])[0][0]
                Z[yi, xi] = z[i]

            fig = plt.figure(figsize=(9, 6))
            ax = fig.add_subplot(111, projection='3d')

            surf = ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none')
            fig.colorbar(surf, ax=ax, label=label_map.get(metric, metric))

            ax.set_xlabel(label_map.get(x_vars[0], x_vars[0]))
            ax.set_ylabel(label_map.get(x_vars[1], x_vars[1]))
            ax.set_zlabel(label_map.get(metric, metric))

            plt.title(
                plot_title if plot_title
                else "Hyperparameter Surface Plot"
            )
        else:
            raise ValueError("Surface plots require exactly two x_vars.")

    else:
        raise ValueError(f"Unsupported plot type: '{plot_type}'. Choose 'line', 'contour', or 'surface'.")

    plt.tight_layout()

    # Save or show
    if output_file:
        plt.savefig(output_file, bbox_inches="tight")
        logging.info(f"Plot saved to {output_file}")
    else:
        plt.show()

    return df
